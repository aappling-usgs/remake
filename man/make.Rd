% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/api.R
\name{make}
\alias{make}
\alias{update}
\title{Make one or more targets}
\usage{
make(target_names = NULL, ..., verbose = TRUE,
  allow_missing_packages = FALSE, remake_file = "remake.yml")

update(target_names = NULL, ..., verbose = TRUE,
  allow_missing_packages = FALSE, remake_file = "remake.yml")
}
\arguments{
\item{target_names}{Character vector of names of targets to build,
or \code{NULL} to build the default target (if specified in the
remakefile).}

\item{...}{Additional future arguments, ignored for now.
Practically this means that all other arguments must be specified
by full name.}

\item{verbose}{Controls whether remake is verbose or not.  The
default (\code{TRUE}) prints out the name of each
target as it is built/checked.  This argument is passed to
\code{\link[=remake_verbose]{remake_verbose()}}; valid options are \code{TRUE},
\code{FALSE} and also the result of calling
\code{\link[=remake_verbose]{remake_verbose()}}.}

\item{allow_missing_packages}{Allow missing packages when loading
remake file?}

\item{remake_file}{Name of the remakefile (by default
\code{remake.yml}).}
}
\description{
\code{make()} builds the selected targets (default: \code{all()}) and all dependencies.

\code{update()} only updates the selected targets (no default),
without checking up-to-date state of dependencies. You should almost always
prefer \code{make()}, unless you have specific reasons not to update dependencies.
}
