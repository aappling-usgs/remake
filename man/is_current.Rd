% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/api.R
\name{is_current}
\alias{is_current}
\title{Determine if targets are current}
\usage{
is_current(target_names, check = NULL, verbose = FALSE,
  allow_missing_packages = FALSE, remake_file = "remake.yml")
}
\arguments{
\item{target_names}{Names of one or more targets to check}

\item{check}{What to check.  By default (\code{check=NULL}) this
will check both code and dependencies unless overridden in the
makerfile.  Other valid options are \code{"exists"} (current if
the target exists), \code{"depends"} (current if exists and
dependencies unchanged), \code{"code"} (current if exists and code
unchanged) or \code{"all"} (current if exists and both
dependencies and code unchanged).}

\item{verbose}{Be verbose when loading remake file?  Default is
\code{FALSE}.}

\item{allow_missing_packages}{Allow missing packages when loading
remake file?}

\item{remake_file}{Name of the remakefile (by default
\code{remake.yml}).}
}
\value{
A logical vector the same length as \code{target_names}.
}
\description{
Determine if one or more targets are "current" or not.  A target
is current if (1) it exists, (2) its immediate dependencies are
unchanged since it was last built and (3) its code is unchanged
since it was last built.
}
\details{
Note that this function does not check all the way down the
dependency tree; so if A depends on B and B depends on C, A may be
current with respect to B but B may be out of date with respect to
C.  Therefore running \code{make} would trigger building B, which
\emph{may} imply rebuilding A.
}
